<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Taotao by qingyunha</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Taotao</h1>
      <h2 class="project-tagline">noting</h2>
      <a href="https://github.com/qingyunha/taotao" class="btn">View on GitHub</a>
      <a href="https://github.com/qingyunha/taotao/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/qingyunha/taotao/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>title: 用Python实现Python解释器
author: Allison Kaptur
translator：陶青云</p>

<p><em>Allison是Dropbox的工程师，在那里她维护着世界上最大的由Python客户组成的网络。在Dropbox之前，她是Recurse Center的引导师, ... 她在北美的PyCon做过关于Python内部机制的演讲，并且她喜欢奇怪的bugs。她的博客地址是<a href="http://akaptur.com">akaptur.com</a>.</em></p>

<h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h2>

<p>Byterun是一个用Python实现的Python解释器。随着我在Byterun上的工作，我惊讶并很高兴地的发现，这个Python解释器的基础结构可以满足500行的限制。在这一章我们会搞清楚这个解释器的结构，给你足够的知识探索下去。我们的目标不是向你展示解释器的每个细节---像编程和计算机科学其他有趣的领域一样，你可能会投入几年的时间去搞清楚这个主题。</p>

<p>Byterun是Ned Batchelder和我完成的，建立在Paul Swartz的工作之上。它的结构和主要的Python实现（CPython）差不多，所以理解Byterun会帮助你理解大多数解释器特别是CPython解释器。（如果你不知道你用的是什么Python，那么很可能它就是CPython）。尽管Byterun不到500行，但它能执行大多数简单的Python程序。</p>

<h3>
<a id="a-python-interpreter" class="anchor" href="#a-python-interpreter" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Python Interpreter</h3>

<p>在开始之前，让我们缩小一下“Pyhton解释器”的意思。在讨论Python的时候，“解释器”这个词可以用在很多不同的地方。有的时候解释器指的是REPL，当你在命令行下敲下<code>python</code>时所得到的交互式环境。有时候人们会相互替代的使用Python解释器和Python来说明执行Python代码的这一过程。在本章，“解释器”有一个更精确的意思：执行Python程序过程中的最后一步。</p>

<p>在解释器接手之前，Python会执行其他3个步骤：词法分析，语法解析和编译。这三步合起来把源代码转换成<em>code object</em>,它包含着解释器可以理解的指令。而解释器的工作就是解释code object中的指令。</p>

<p>你可能很奇怪执行Python代码会有编译这一步。Python通常被称为解释型语言，就像Ruby，Perl一样，它们和编译型语言相对，比如C，Rust。然而，这里的术语并不是它看起来的那样精确。大多数解释型语言包括Python，确实会有编译这一步。而Python被称为解释型的原因是相对于编译型语言，它在编译这一步的工作相对较少（解释器做相对多的工作）。在这章后面你会看到，Python的编译器比C语言编译器需要更少的关于程序行为的信息。</p>

<h3>
<a id="a-python-python-interpreter" class="anchor" href="#a-python-python-interpreter" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Python Python Interpreter</h3>

<p>Byterun是一个用Python写的Python解释器，这点可能让你感到奇怪，但没有比用C语言写C语言编译器更奇怪。（事实上，广泛使用的gcc编译器就是用C语言本身写的）你可以用几乎的任何语言写一个Python解释器。</p>

<p>用Python写Python既有有点又有缺点。最大的缺点就是速度：用Byterun执行代码要比用CPython执行慢的多，CPython解释器是用C语言实现的并做了优化。然而Byterun是为了学习而设计的，所以速度对我们不重要。使用Python最大优点是我们可以<em>仅仅</em>实现解释器，而不用担心Python运行时的部分，特别是对象系统。比如当Byterun需要创建一个类时，它就会回退到“真正”的Python。另外一个优势是Byterun很容易理解，部分原因是它是用高级语言写的（Python！）（另外我们不会对解释器做优化 --- 再一次，清晰和简单比速度更重要）</p>

<h2>
<a id="building-an-interpreter" class="anchor" href="#building-an-interpreter" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building an Interpreter</h2>

<p>在我们考察Byterun代码之前，我们需要一些对解释器的结构的高层次视角。Python解释器是如何工作的？</p>

<p>Python解释器是一个<em>虚拟机</em>,模拟真实的计算机的软件。我们这个虚拟机是栈机器，它用几个栈来完成操作（与之相对的是寄存器机器，它从特定的内存地址读写数据）。</p>

<p>Python解释器是一个<em>字节码解释器</em>：它的输入是一些命令集合称作<em>字节码</em>。当你写Python代码时，词法分析器，语法解析器和编译器生成code object让解释器去操作。每个code object都包含一个要被执行的指令集合 --- 它就是字节码 --- 另外还有一些解释器需要的信息。字节码是Python代码的一个<em>中间层表示</em>：它以一种解释器可以理解的方式来表示源代码。这和汇编语言作为C语言和机器语言的中间表示很类似。</p>

<h3>
<a id="a-tiny-interpreter" class="anchor" href="#a-tiny-interpreter" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Tiny Interpreter</h3>

<p>To make this concrete, let's start with a very minimal interpreter. This interpreter can only add numbers, and it understands just three instructions. All code it can execute consists of these three instructions in different combinations. The three instructions are these:</p>

<ul>
<li><code>LOAD_VALUE</code></li>
<li><code>ADD_TWO_VALUES</code></li>
<li><code>PRINT_ANSWER</code></li>
</ul>

<p>Since we're not concerned with the lexer, parser, and compiler in this chapter, it doesn't matter how the instruction sets are produced.  You can imagine writing <code>7 + 5</code> and having a compiler emit a combination of these three instructions. Or, if you have the right compiler, you can write Lisp syntax that's turned into the same combination of instructions. The interpreter doesn't care. All that matters is that our interpreter is given a well-formed arrangement of the instructions.</p>

<p>Suppose that</p>

<div class="highlight highlight-source-python"><pre><span class="pl-c1">7</span> <span class="pl-k">+</span> <span class="pl-c1">5</span></pre></div>

<p>produces this instruction set:</p>

<div class="highlight highlight-source-python"><pre>what_to_execute <span class="pl-k">=</span> {
    <span class="pl-s"><span class="pl-pds">"</span>instructions<span class="pl-pds">"</span></span>: [(<span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>),  <span class="pl-c"># the first number</span>
                     (<span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>),  <span class="pl-c"># the second number</span>
                     (<span class="pl-s"><span class="pl-pds">"</span>ADD_TWO_VALUES<span class="pl-pds">"</span></span>, <span class="pl-c1">None</span>),
                     (<span class="pl-s"><span class="pl-pds">"</span>PRINT_ANSWER<span class="pl-pds">"</span></span>, <span class="pl-c1">None</span>)],
    <span class="pl-s"><span class="pl-pds">"</span>numbers<span class="pl-pds">"</span></span>: [<span class="pl-c1">7</span>, <span class="pl-c1">5</span>] }</pre></div>

<p>The Python interpreter is a <em>stack machine</em>, so it must manipulate stacks to add two numbers (\aosafigref{500l.interpreter.stackmachine}.) The interpreter will begin by executing the first instruction, <code>LOAD_VALUE</code>, and pushing the first number onto the stack. Next it will push the second number onto the stack. For the third instruction, <code>ADD_TWO_VALUES</code>, it will pop both numbers off, add them together, and push the result onto the stack. Finally, it will pop the answer back off the stack and print it.</p>

<p>\aosafigure[240pt]{interpreter-images/interpreter-stack.png}{A stack machine}{500l.interpreter.stackmachine}</p>

<p>The <code>LOAD_VALUE</code> instruction tells the interpreter to push a number on to the stack, but the instruction alone doesn't specify which number. Each instruction needs an extra piece of information, telling the interpreter where to find the number to load. So our instruction set has two pieces: the instructions themselves, plus a list of constants the instructions will need. (In Python, what we're calling "instructions" is the bytecode, and the entire "what to execute" object below is the <em>code object</em>.)</p>

<p>Why not just put the numbers directly in the instructions? Imagine if we were adding strings together instead of numbers. We wouldn't want to have the strings stuffed in with the instructions, since they could be arbitrarily large. This design also means we can have just one copy of each object that we need, so for example to add <code>7 + 7</code>, <code>"numbers"</code> could be just <code>[7]</code>.</p>

<p>You may be wondering why instructions other than <code>ADD_TWO_VALUES</code> were needed at all. Indeed, for the simple case of adding two numbers, the example is a little contrived. However, this instruction is a building block for more complex programs. For example, with just the instructions we've defined so far, we can already add together three values --- or any number of values --- given the right set of these instructions. The stack provides a clean way to keep track of the state of the interpreter, and it will support more complexity as we go along.</p>

<p>Now let's start to write the interpreter itself. The interpreter object has a stack, which we'll represent with a list. The object also has a method describing how to execute each instruction. For example, for <code>LOAD_VALUE</code>, the interpreter will push the value onto the stack.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">Interpreter</span>:
    <span class="pl-k">def</span> <span class="pl-en"><span class="pl-c1">__init__</span></span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.stack <span class="pl-k">=</span> []

    <span class="pl-k">def</span> <span class="pl-en">LOAD_VALUE</span>(<span class="pl-smi">self</span>, <span class="pl-smi">number</span>):
        <span class="pl-v">self</span>.stack.append(number)

    <span class="pl-k">def</span> <span class="pl-en">PRINT_ANSWER</span>(<span class="pl-smi">self</span>):
        answer <span class="pl-k">=</span> <span class="pl-v">self</span>.stack.pop()
        <span class="pl-k">print</span>(answer)

    <span class="pl-k">def</span> <span class="pl-en">ADD_TWO_VALUES</span>(<span class="pl-smi">self</span>):
        first_num <span class="pl-k">=</span> <span class="pl-v">self</span>.stack.pop()
        second_num <span class="pl-k">=</span> <span class="pl-v">self</span>.stack.pop()
        total <span class="pl-k">=</span> first_num <span class="pl-k">+</span> second_num
        <span class="pl-v">self</span>.stack.append(total)</pre></div>

<p>These three functions implement the three instructions our interpreter understands. The interpreter needs one more piece: a way to tie everything together and actually execute it. This method, <code>run_code</code>, takes the <code>what_to_execute</code> dictionary defined above as an argument. It loops over each instruction, processes the arguments to that instruction if there are any, and then calls the corresponding method on the interpreter object.</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">run_code</span>(<span class="pl-smi">self</span>, <span class="pl-smi">what_to_execute</span>):
        instructions <span class="pl-k">=</span> what_to_execute[<span class="pl-s"><span class="pl-pds">"</span>instructions<span class="pl-pds">"</span></span>]
        numbers <span class="pl-k">=</span> what_to_execute[<span class="pl-s"><span class="pl-pds">"</span>numbers<span class="pl-pds">"</span></span>]
        <span class="pl-k">for</span> each_step <span class="pl-k">in</span> instructions:
            instruction, argument <span class="pl-k">=</span> each_step
            <span class="pl-k">if</span> instruction <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>:
                number <span class="pl-k">=</span> numbers[argument]
                <span class="pl-v">self</span>.LOAD_VALUE(number)
            <span class="pl-k">elif</span> instruction <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>ADD_TWO_VALUES<span class="pl-pds">"</span></span>:
                <span class="pl-v">self</span>.ADD_TWO_VALUES()
            <span class="pl-k">elif</span> instruction <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>PRINT_ANSWER<span class="pl-pds">"</span></span>:
                <span class="pl-v">self</span>.PRINT_ANSWER()</pre></div>

<p>To test it out, we can create an instance of the object and then call the <code>run_code</code> method with the instruction set for adding 7 + 5 defined above.</p>

<div class="highlight highlight-source-python"><pre>    interpreter <span class="pl-k">=</span> Interpreter()
    interpreter.run_code(what_to_execute)</pre></div>

<p>Sure enough, it prints the answer: 12.</p>

<p>Although this interpreter is quite limited, this process is almost exactly how the real Python interpreter adds numbers. There are a couple of things to note even in this small example.  </p>

<p>First of all, some instructions need arguments. In real Python bytecode, about half of instructions have arguments. The arguments are packed in with the instructions, much like in our example. Notice that the arguments to the <em>instructions</em> are different than the arguments to the methods that are called.</p>

<p>Second, notice that the instruction for <code>ADD_TWO_VALUES</code> did not require any arguments. Instead, the values to be added together were popped off the interpreter's stack. This is the defining feature of a stack-based interpreter.</p>

<p>Remember that given valid instruction sets, without any changes to our interpreter, we can add more than two numbers at a time. Consider the instruction set below. What do you expect to happen? If you had a friendly compiler, what code could you write to generate this instruction set?</p>

<div class="highlight highlight-source-python"><pre>    what_to_execute <span class="pl-k">=</span> {
        <span class="pl-s"><span class="pl-pds">"</span>instructions<span class="pl-pds">"</span></span>: [(<span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>ADD_TWO_VALUES<span class="pl-pds">"</span></span>, <span class="pl-c1">None</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>ADD_TWO_VALUES<span class="pl-pds">"</span></span>, <span class="pl-c1">None</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>PRINT_ANSWER<span class="pl-pds">"</span></span>, <span class="pl-c1">None</span>)],
        <span class="pl-s"><span class="pl-pds">"</span>numbers<span class="pl-pds">"</span></span>: [<span class="pl-c1">7</span>, <span class="pl-c1">5</span>, <span class="pl-c1">8</span>] }</pre></div>

<p>At this point, we can begin to see how this structure is extensible: we can add methods on the interpreter object that describe many more operations (as long as we have a compiler to hand us well-formed instruction sets).</p>

<h4>
<a id="variables" class="anchor" href="#variables" aria-hidden="true"><span class="octicon octicon-link"></span></a>Variables</h4>

<p>Next let's add variables to our interpreter. Variables require an instruction for storing the value of a variable, <code>STORE_NAME</code>; an instruction for retrieving it, <code>LOAD_NAME</code>; and a mapping from variable names to values. For now, we'll ignore namespaces and scoping, so we can store the variable mapping on the interpreter object itself. Finally, we'll have to make sure that <code>what_to_execute</code> has a list of the variable names, in addition to its list of constants.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-k">def</span> s():
...     a <span class="pl-k">=</span> <span class="pl-c1">1</span>
...     b <span class="pl-k">=</span> <span class="pl-c1">2</span>
...     <span class="pl-k">print</span>(a <span class="pl-k">+</span> b)
<span class="pl-c"># a friendly compiler transforms `s` into:</span>
    what_to_execute <span class="pl-k">=</span> {
        <span class="pl-s"><span class="pl-pds">"</span>instructions<span class="pl-pds">"</span></span>: [(<span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>STORE_NAME<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>STORE_NAME<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>LOAD_NAME<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>LOAD_NAME<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>ADD_TWO_VALUES<span class="pl-pds">"</span></span>, <span class="pl-c1">None</span>),
                         (<span class="pl-s"><span class="pl-pds">"</span>PRINT_ANSWER<span class="pl-pds">"</span></span>, <span class="pl-c1">None</span>)],
        <span class="pl-s"><span class="pl-pds">"</span>numbers<span class="pl-pds">"</span></span>: [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>],
        <span class="pl-s"><span class="pl-pds">"</span>names<span class="pl-pds">"</span></span>:   [<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>] }</pre></div>

<p>Our new implementation is below. To keep track of what names are bound to what values, we'll add an <code>environment</code> dictionary to the <code>__init__</code> method. We'll also add <code>STORE_NAME</code> and <code>LOAD_NAME</code>. These methods first look up the variable name in question and then use the dictionary to store or retrieve its value.</p>

<p>The arguments to an instruction can now mean two different things: They can either be an index into the "numbers" list, or they can be an index into the "names" list. The interpreter knows which it should be by checking what instruction it's executing. We'll break out this logic --- and the mapping of instructions to what their arguments mean --- into a separate method.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">Interpreter</span>:
    <span class="pl-k">def</span> <span class="pl-en"><span class="pl-c1">__init__</span></span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.stack <span class="pl-k">=</span> []
        <span class="pl-v">self</span>.environment <span class="pl-k">=</span> {}

    <span class="pl-k">def</span> <span class="pl-en">STORE_NAME</span>(<span class="pl-smi">self</span>, <span class="pl-smi">name</span>):
        val <span class="pl-k">=</span> <span class="pl-v">self</span>.stack.pop()
        <span class="pl-v">self</span>.environment[name] <span class="pl-k">=</span> val

    <span class="pl-k">def</span> <span class="pl-en">LOAD_NAME</span>(<span class="pl-smi">self</span>, <span class="pl-smi">name</span>):
        val <span class="pl-k">=</span> <span class="pl-v">self</span>.environment[name]
        <span class="pl-v">self</span>.stack.append(val)

    <span class="pl-k">def</span> <span class="pl-en">parse_argument</span>(<span class="pl-smi">self</span>, <span class="pl-smi">instruction</span>, <span class="pl-smi">argument</span>, <span class="pl-smi">what_to_execute</span>):
        <span class="pl-s"><span class="pl-pds">"""</span> Understand what the argument to each instruction means.<span class="pl-pds">"""</span></span>
        numbers <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>]
        names <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>LOAD_NAME<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>STORE_NAME<span class="pl-pds">"</span></span>]

        <span class="pl-k">if</span> instruction <span class="pl-k">in</span> numbers:
            argument <span class="pl-k">=</span> what_to_execute[<span class="pl-s"><span class="pl-pds">"</span>numbers<span class="pl-pds">"</span></span>][argument]
        <span class="pl-k">elif</span> instruction <span class="pl-k">in</span> names:
            argument <span class="pl-k">=</span> what_to_execute[<span class="pl-s"><span class="pl-pds">"</span>names<span class="pl-pds">"</span></span>][argument]

        <span class="pl-k">return</span> argument

    <span class="pl-k">def</span> <span class="pl-en">run_code</span>(<span class="pl-smi">self</span>, <span class="pl-smi">what_to_execute</span>):
        instructions <span class="pl-k">=</span> what_to_execute[<span class="pl-s"><span class="pl-pds">"</span>instructions<span class="pl-pds">"</span></span>]
        <span class="pl-k">for</span> each_step <span class="pl-k">in</span> instructions:
            instruction, argument <span class="pl-k">=</span> each_step
            argument <span class="pl-k">=</span> <span class="pl-v">self</span>.parse_argument(instruction, argument, what_to_execute)

            <span class="pl-k">if</span> instruction <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>LOAD_VALUE<span class="pl-pds">"</span></span>:
                <span class="pl-v">self</span>.LOAD_VALUE(argument)
            <span class="pl-k">elif</span> instruction <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>ADD_TWO_VALUES<span class="pl-pds">"</span></span>:
                <span class="pl-v">self</span>.ADD_TWO_VALUES()
            <span class="pl-k">elif</span> instruction <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>PRINT_ANSWER<span class="pl-pds">"</span></span>:
                <span class="pl-v">self</span>.PRINT_ANSWER()
            <span class="pl-k">elif</span> instruction <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>STORE_NAME<span class="pl-pds">"</span></span>:
                <span class="pl-v">self</span>.STORE_NAME(argument)
            <span class="pl-k">elif</span> instruction <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>LOAD_NAME<span class="pl-pds">"</span></span>:
                <span class="pl-v">self</span>.LOAD_NAME(argument)</pre></div>

<p>Even with just five instructions, the <code>run_code</code> method is starting to get tedious. If we kept this structure, we'd need one branch of the <code>if</code> statement for each instruction. Here, we can make use of Python's dynamic method lookup. We'll always define a method called <code>FOO</code> to execute the instruction called <code>FOO</code>, so we can use Python's <code>getattr</code> function to look up the method on the fly instead of using the big <code>if</code> statement. The <code>run_code</code> method then looks like this:</p>

<div class="highlight highlight-source-python"><pre>    <span class="pl-k">def</span> <span class="pl-en">execute</span>(<span class="pl-smi">self</span>, <span class="pl-smi">what_to_execute</span>):
        instructions <span class="pl-k">=</span> what_to_execute[<span class="pl-s"><span class="pl-pds">"</span>instructions<span class="pl-pds">"</span></span>]
        <span class="pl-k">for</span> each_step <span class="pl-k">in</span> instructions:
            instruction, argument <span class="pl-k">=</span> each_step
            argument <span class="pl-k">=</span> <span class="pl-v">self</span>.parse_argument(instruction, argument, what_to_execute)
            bytecode_method <span class="pl-k">=</span> <span class="pl-c1">getattr</span>(<span class="pl-v">self</span>, instruction)
            <span class="pl-k">if</span> argument <span class="pl-k">is</span> <span class="pl-c1">None</span>:
                bytecode_method()
            <span class="pl-k">else</span>:
                bytecode_method(argument)</pre></div>

<h2>
<a id="real-python-bytecode" class="anchor" href="#real-python-bytecode" aria-hidden="true"><span class="octicon octicon-link"></span></a>Real Python Bytecode</h2>

<p>At this point, we'll abandon our toy instruction sets and switch to real Python bytecode. The structure of bytecode is similar to our toy interpreter's verbose instruction sets, except that it uses one byte instead of a long name to identify each instruction. To understand this structure, we'll walk through the bytecode of a short function. Consider the example below:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-k">def</span> cond():
...     x <span class="pl-k">=</span> <span class="pl-c1">3</span>
...     <span class="pl-k">if</span> x <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>:
...         <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>yes<span class="pl-pds">'</span></span>
...     <span class="pl-k">else</span>:
...         <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>no<span class="pl-pds">'</span></span>
...</pre></div>

<p>Python exposes a boatload of its internals at run time, and we can access them right from the REPL. For the function object <code>cond</code>, <code>cond.__code__</code> is the code object associated it, and <code>cond.__code__.co_code</code> is the bytecode. There's almost never a good reason to use these attributes directly when you're writing Python code, but they do allow us to get up to all sorts of mischief --- and to look at the internals in order to understand them.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> cond.<span class="pl-c1">__code__</span>.co_code  <span class="pl-c"># the bytecode as raw bytes</span>
b<span class="pl-s"><span class="pl-pds">'</span>d<span class="pl-cce">\x01\x00</span>}<span class="pl-cce">\x00\x00</span>|<span class="pl-cce">\x00\x00</span>d<span class="pl-cce">\x02\x00</span>k<span class="pl-cce">\x00\x00</span>r<span class="pl-cce">\x16\x00</span>d<span class="pl-cce">\x03\x00</span>Sd<span class="pl-cce">\x04\x00</span>Sd<span class="pl-cce">\x00</span><span class="pl-ii"></span></span>
   \<span class="pl-ii">x00S'</span>
<span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-c1">list</span>(cond.<span class="pl-c1">__code__</span>.co_code)  <span class="pl-c"># the bytecode as numbers</span>
[<span class="pl-c1">100</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">125</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">124</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">100</span>, <span class="pl-c1">2</span>, <span class="pl-c1">0</span>, <span class="pl-c1">107</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">114</span>, <span class="pl-c1">22</span>, <span class="pl-c1">0</span>, <span class="pl-c1">100</span>, <span class="pl-c1">3</span>, <span class="pl-c1">0</span>, <span class="pl-c1">83</span>, 
 <span class="pl-c1">100</span>, <span class="pl-c1">4</span>, <span class="pl-c1">0</span>, <span class="pl-c1">83</span>, <span class="pl-c1">100</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">83</span>]</pre></div>

<p>When we just print the bytecode, it looks unintelligible --- all we can tell is that it's a series of bytes. Luckily, there's a powerful tool we can use to understand it: the <code>dis</code> module in the Python standard library. </p>

<p><code>dis</code> is a bytecode disassembler. A disassembler takes low-level code that is written for machines, like assembly code or bytecode, and prints it in a human-readable way. When we run <code>dis.dis</code>, it outputs an explanation of the bytecode it has passed.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> dis.dis(cond)
  <span class="pl-c1">2</span>           <span class="pl-c1">0</span> LOAD_CONST               <span class="pl-c1">1</span> (<span class="pl-c1">3</span>)
              <span class="pl-c1">3</span> STORE_FAST               <span class="pl-c1">0</span> (x)

  <span class="pl-c1">3</span>           <span class="pl-c1">6</span> LOAD_FAST                <span class="pl-c1">0</span> (x)
              <span class="pl-c1">9</span> LOAD_CONST               <span class="pl-c1">2</span> (<span class="pl-c1">5</span>)
             <span class="pl-c1">12</span> COMPARE_OP               <span class="pl-c1">0</span> (<span class="pl-k">&lt;</span>)
             <span class="pl-c1">15</span> POP_JUMP_IF_FALSE       <span class="pl-c1">22</span>

  <span class="pl-c1">4</span>          <span class="pl-c1">18</span> LOAD_CONST               <span class="pl-c1">3</span> (<span class="pl-s"><span class="pl-pds">'</span>yes<span class="pl-pds">'</span></span>)
             <span class="pl-c1">21</span> RETURN_VALUE

  <span class="pl-c1">6</span>     <span class="pl-k">&gt;&gt;</span>   <span class="pl-c1">22</span> LOAD_CONST               <span class="pl-c1">4</span> (<span class="pl-s"><span class="pl-pds">'</span>no<span class="pl-pds">'</span></span>)
             <span class="pl-c1">25</span> RETURN_VALUE
             <span class="pl-c1">26</span> LOAD_CONST               <span class="pl-c1">0</span> (<span class="pl-c1">None</span>)
             <span class="pl-c1">29</span> RETURN_VALUE</pre></div>

<p>What does all this mean? Let's look at the first instruction <code>LOAD_CONST</code> as an example. The number in the first column (<code>2</code>) shows the line number in our Python source code. The second column is an index into the bytecode, telling us that the <code>LOAD_CONST</code> instruction appears at position zero.  The third column is the instruction itself, mapped to its human-readable name. The fourth column, when present, is the argument to that instruction.  The fifth column, when present, is a hint about what the argument means.</p>

<p>Consider the first few bytes of this bytecode: [100, 1, 0, 125, 0, 0]. These six bytes represent two instructions with their arguments. We can use <code>dis.opname</code>, a mapping from bytes to intelligible strings, to find out what instructions 100 and 125 map to:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> dis.opname[<span class="pl-c1">100</span>]
<span class="pl-s"><span class="pl-pds">'</span>LOAD_CONST<span class="pl-pds">'</span></span>
<span class="pl-k">&gt;&gt;&gt;</span> dis.opname[<span class="pl-c1">125</span>]
<span class="pl-s"><span class="pl-pds">'</span>STORE_FAST<span class="pl-pds">'</span></span></pre></div>

<p>The second and third bytes --- 1, 0 --- are arguments to <code>LOAD_CONST</code>, while the fifth and sixth bytes --- 0, 0 --- are arguments to <code>STORE_FAST</code>. Just like in our toy example, <code>LOAD_CONST</code> needs to know where to find its constant to load, and <code>STORE_FAST</code> needs to find the name to store. (Python's <code>LOAD_CONST</code> is the same as our toy interpreter's <code>LOAD_VALUE</code>, and <code>LOAD_FAST</code> is the same as <code>LOAD_NAME</code>.) So these six bytes represent the first line of code, <code>x = 3</code>. (Why use two bytes for each argument? If Python used just one byte to locate constants and names instead of two, you could only have 256 names/constants associated with a single code object. Using two bytes, you can have up to 256 squared, or 65,536.)</p>

<h3>
<a id="conditionals-and-loops" class="anchor" href="#conditionals-and-loops" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conditionals and Loops</h3>

<p>So far, the interpreter has executed code simply by stepping through the instructions one by one. This is a problem; often, we want to execute certain instructions many times, or skip them under certain conditions. To allow us to write loops and if statements in our code, the interpreter must be able to jump around in the instruction set. In a sense, Python handles loops and conditionals with <code>GOTO</code> statements in the bytecode! Look at the disassembly of the function <code>cond</code> again:</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> dis.dis(cond)
  <span class="pl-c1">2</span>           <span class="pl-c1">0</span> LOAD_CONST               <span class="pl-c1">1</span> (<span class="pl-c1">3</span>)
              <span class="pl-c1">3</span> STORE_FAST               <span class="pl-c1">0</span> (x)

  <span class="pl-c1">3</span>           <span class="pl-c1">6</span> LOAD_FAST                <span class="pl-c1">0</span> (x)
              <span class="pl-c1">9</span> LOAD_CONST               <span class="pl-c1">2</span> (<span class="pl-c1">5</span>)
             <span class="pl-c1">12</span> COMPARE_OP               <span class="pl-c1">0</span> (<span class="pl-k">&lt;</span>)
             <span class="pl-c1">15</span> POP_JUMP_IF_FALSE       <span class="pl-c1">22</span>

  <span class="pl-c1">4</span>          <span class="pl-c1">18</span> LOAD_CONST               <span class="pl-c1">3</span> (<span class="pl-s"><span class="pl-pds">'</span>yes<span class="pl-pds">'</span></span>)
             <span class="pl-c1">21</span> RETURN_VALUE

  <span class="pl-c1">6</span>     <span class="pl-k">&gt;&gt;</span>   <span class="pl-c1">22</span> LOAD_CONST               <span class="pl-c1">4</span> (<span class="pl-s"><span class="pl-pds">'</span>no<span class="pl-pds">'</span></span>)
             <span class="pl-c1">25</span> RETURN_VALUE
             <span class="pl-c1">26</span> LOAD_CONST               <span class="pl-c1">0</span> (<span class="pl-c1">None</span>)
             <span class="pl-c1">29</span> RETURN_VALUE</pre></div>

<p>The conditional <code>if x &lt; 5</code> on line 3 of the code is compiled into four instructions: <code>LOAD_FAST</code>, <code>LOAD_CONST</code>, <code>COMPARE_OP</code>, and <code>POP_JUMP_IF_FALSE</code>. <code>x &lt; 5</code> generates code to load <code>x</code>, load 5, and compare the two values. The instruction <code>POP_JUMP_IF_FALSE</code> is responsible for implementing the <code>if</code>. This instruction will pop the top value off the interpreter's stack. If the value is true, then nothing happens. (The value can be "truthy" --- it doesn't have to be the literal <code>True</code> object.) If the value is false, then the interpreter will jump to another instruction.</p>

<p>The instruction to land on is called the jump target, and it's provided as the argument to the <code>POP_JUMP</code> instruction. Here, the jump target is 22. The instruction at index 22 is <code>LOAD_CONST</code> on line 6. (<code>dis</code> marks jump targets with <code>&gt;&gt;</code>.) If the result of <code>x &lt; 5</code> is False, then the interpreter will jump straight to line 6 (<code>return "no"</code>), skipping line 4 (<code>return "yes"</code>). Thus, the interpreter uses jump instructions to selectively skip over parts of the instruction set.</p>

<p>Python loops also rely on jumping. In the bytecode below, notice that the line <code>while x &lt; 5</code> generates almost identical bytecode to <code>if x &lt; 10</code>. In both cases, the comparison is calculated and then <code>POP_JUMP_IF_FALSE</code> controls which instruction is executed next. At the end of line 4 --- the end of the loop's body --- the instruction <code>JUMP_ABSOLUTE</code> always sends the interpreter back to instruction 9 at the top of the loop. When x &lt; 10 becomes false, then <code>POP_JUMP_IF_FALSE</code> jumps the interpreter past the end of the loop, to instruction 34. </p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-k">def</span> loop():
...      x <span class="pl-k">=</span> <span class="pl-c1">1</span>
...      <span class="pl-k">while</span> x <span class="pl-k">&lt;</span> <span class="pl-c1">5</span>:
...          x <span class="pl-k">=</span> x <span class="pl-k">+</span> <span class="pl-c1">1</span>
...      <span class="pl-k">return</span> x
...
<span class="pl-k">&gt;&gt;&gt;</span> dis.dis(loop)
  <span class="pl-c1">2</span>           <span class="pl-c1">0</span> LOAD_CONST               <span class="pl-c1">1</span> (<span class="pl-c1">1</span>)
              <span class="pl-c1">3</span> STORE_FAST               <span class="pl-c1">0</span> (x)

  <span class="pl-c1">3</span>           <span class="pl-c1">6</span> SETUP_LOOP              <span class="pl-c1">26</span> (to <span class="pl-c1">35</span>)
        <span class="pl-k">&gt;&gt;</span>    <span class="pl-c1">9</span> LOAD_FAST                <span class="pl-c1">0</span> (x)
             <span class="pl-c1">12</span> LOAD_CONST               <span class="pl-c1">2</span> (<span class="pl-c1">5</span>)
             <span class="pl-c1">15</span> COMPARE_OP               <span class="pl-c1">0</span> (<span class="pl-k">&lt;</span>)
             <span class="pl-c1">18</span> POP_JUMP_IF_FALSE       <span class="pl-c1">34</span>

  <span class="pl-c1">4</span>          <span class="pl-c1">21</span> LOAD_FAST                <span class="pl-c1">0</span> (x)
             <span class="pl-c1">24</span> LOAD_CONST               <span class="pl-c1">1</span> (<span class="pl-c1">1</span>)
             <span class="pl-c1">27</span> BINARY_ADD
             <span class="pl-c1">28</span> STORE_FAST               <span class="pl-c1">0</span> (x)
             <span class="pl-c1">31</span> JUMP_ABSOLUTE            <span class="pl-c1">9</span>
        <span class="pl-k">&gt;&gt;</span>   <span class="pl-c1">34</span> POP_BLOCK

  <span class="pl-c1">5</span>     <span class="pl-k">&gt;&gt;</span>   <span class="pl-c1">35</span> LOAD_FAST                <span class="pl-c1">0</span> (x)
             <span class="pl-c1">38</span> RETURN_VALUE</pre></div>

<h3>
<a id="explore-bytecode" class="anchor" href="#explore-bytecode" aria-hidden="true"><span class="octicon octicon-link"></span></a>Explore Bytecode</h3>

<p>I encourage you to try running <code>dis.dis</code> on functions you write. Some interesting questions to explore are:</p>

<ul>
<li>What's the difference between a for loop and a while loop to the Python interpreter?</li>
<li>How can you write different functions that generate identical bytecode?</li>
<li>How does <code>elif</code> work? What about list comprehensions?</li>
</ul>

<h2>
<a id="frames" class="anchor" href="#frames" aria-hidden="true"><span class="octicon octicon-link"></span></a>Frames</h2>

<p>So far, we've learned that the Python virtual machine is a stack machine. It steps and jumps through instructions, pushing and popping values on and off a stack. There are still some gaps in our mental model, though. In the examples above, the last instruction is <code>RETURN_VALUE</code>, which corresponds to the <code>return</code> statement in the code. But where does the instruction return to?</p>

<p>To answer this question, we must add one additional layer of complexity: the frame. A frame is a collection of information and context for a chunk of code. Frames are created and destroyed on the fly as your Python code executes. There's one frame corresponding to each <em>call</em> of a function --- so while each frame has one code object associated with it, a code object can have many frames. If you had a function that called itself recursively ten times, you'd have eleven frames --- one for each level of recursion and one for the module you started from. In general, there's a frame for each scope in a Python program. For example, each module, each function call, and each class definition has a frame.</p>

<p>Frames live on the <em>call stack</em>, a completely different stack from the one we've been discussing so far. (The call stack is the stack you're most familiar with already --- you've seen it printed out in the tracebacks of exceptions. Each line in a traceback starting with "File 'program.py', line 10" corresponds to one frame on the call stack.) The stack we've been examining --- the one the interpreter is manipulating while it executes bytecode --- we'll call the <em>data stack</em>. There's also a third stack, called the <em>block stack</em>. Blocks are used for certain kinds of control flow, particularly looping and exception handling. Each frame on the call stack has its own data stack and block stack.</p>

<p>Let's make this concrete with an example. Suppose the Python interpreter is currently executing the line marked 3 below. The interpreter is in the middle of a call to <code>foo</code>, which is in turn calling <code>bar</code>. The diagram shows a schematic of the call stack of frames, the block stacks, and the data stacks. (This code is written like a REPL session, so we've first defined the needed functions.) At the moment we're interested in, the interpreter is executing <code>foo()</code>, at the bottom, which then reaches in to the body of <code>foo</code> and then up into <code>bar</code>.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-k">def</span> bar(y):
...     z <span class="pl-k">=</span> y <span class="pl-k">+</span> <span class="pl-c1">3</span>     <span class="pl-c"># &lt;--- (3) ... and the interpreter is here.</span>
...     <span class="pl-k">return</span> z
...
<span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-k">def</span> foo():
...     a <span class="pl-k">=</span> <span class="pl-c1">1</span>
...     b <span class="pl-k">=</span> <span class="pl-c1">2</span>
...     <span class="pl-k">return</span> a <span class="pl-k">+</span> bar(b) <span class="pl-c"># &lt;--- (2) ... which is returning a call to bar ...</span>
...
<span class="pl-k">&gt;&gt;&gt;</span> foo()             <span class="pl-c"># &lt;--- (1) We're in the middle of a call to foo ...</span>
<span class="pl-c1">3</span></pre></div>

<p>\aosafigure[240pt]{interpreter-images/interpreter-callstack.png}{The call stack}{500l.interpreter.callstack}</p>

<p>At this point, the interpreter is in the middle of the function call to <code>bar</code>. There are three frames on the call stack: one for the module level, one for the function <code>foo</code>, and one for <code>bar</code> (\aosafigref{500l.interpreter.callstack}.) Once <code>bar</code> returns, the frame associated with it is popped off the call stack and discarded.</p>

<p>The bytecode instruction <code>RETURN_VALUE</code> tells the interpreter to pass a value between frames. First it will pop the top value off the data stack of the top frame on the call stack. Then it pops the entire frame off the call stack and throws it away. Finally, the value is pushed onto the data stack on the next frame down.</p>

<p>When Ned Batchelder and I were working on Byterun, for a long time we had a significant error in our implementation. Instead of having one data stack on each frame, we had just one data stack on the entire virtual machine. We had dozens of tests made up of little snippets of Python code which we ran through Byterun and through the real Python interpreter to make sure the same thing happened in both interpreters. Nearly all of these tests were passing. The only thing we couldn't get working was generators. Finally, reading the CPython code more carefully, we realized the mistake[^thanks]. Moving a data stack onto each frame fixed the problem.</p>

<p>[^thanks]: My thanks to Michael Arntzenius for his insight on this bug. </p>

<p>Looking back on this bug, I was amazed at how little of Python relied on each frame having a different data stack. Nearly all operations in the Python interpreter carefully clean up the data stack, so the fact that the frames were sharing the same stack didn't matter. In the example above, when <code>bar</code> finishes executing, it'll leave its data stack empty. Even if <code>foo</code> shared the same stack, the values would be lower down. However, with generators, a key feature is the ability to pause a frame, return to some other frame, and then return to the generator frame later and have it be in exactly the same state that you left it.</p>

<h2>
<a id="byterun" class="anchor" href="#byterun" aria-hidden="true"><span class="octicon octicon-link"></span></a>Byterun</h2>

<p>We now have enough context about the Python interpreter to begin examining Byterun. </p>

<p>There are four kinds of objects in Byterun:</p>

<ul>
<li>A <code>VirtualMachine</code> class, which manages the highest-level structure, particularly the call stack of frames, and contains a mapping of instructions to operations. This is a more complex version of the <code>Intepreter</code> object above.</li>
<li>A <code>Frame</code> class.  Every <code>Frame</code> instance has one code object and manages a few other necessary bits of state, particularly the global and local namespaces, a reference to the calling frame, and the last bytecode instruction executed.</li>
<li>A <code>Function</code> class, which will be used in place of real Python functions. Recall that calling a function creates a new frame in the interpreter. We implement Function so that we control the creation of new Frames.</li>
<li>A <code>Block</code> class, which just wraps the three attributes of blocks. (The details of blocks aren't central to the Python interpreter, so we won't spend much time on them, but they're included here so that Byterun can run real Python code.)</li>
</ul>

<h3>
<a id="the-virtualmachine-class" class="anchor" href="#the-virtualmachine-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>The <code>VirtualMachine</code> Class</h3>

<p>Only one instance of <code>VirtualMachine</code> will be created each time the program is run, because we only have one Python interpreter. <code>VirtualMachine</code> stores the call stack, the exception state, and return values while they're being passed between frames. The entry point for executing code is the method <code>run_code</code>, which takes a compiled code object as an argument. It starts by setting up and running a frame. This frame may create other frames; the call stack will grow and shrink as the program executes. When the first frame eventually returns, execution is finished.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">VirtualMachineError</span>(<span class="pl-e"><span class="pl-c1">Exception</span></span>):
    <span class="pl-k">pass</span>

<span class="pl-k">class</span> <span class="pl-en">VirtualMachine</span>(<span class="pl-e"><span class="pl-c1">object</span></span>):
    <span class="pl-k">def</span> <span class="pl-en"><span class="pl-c1">__init__</span></span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.frames <span class="pl-k">=</span> []   <span class="pl-c"># The call stack of frames.</span>
        <span class="pl-v">self</span>.frame <span class="pl-k">=</span> <span class="pl-c1">None</span>  <span class="pl-c"># The current frame.</span>
        <span class="pl-v">self</span>.return_value <span class="pl-k">=</span> <span class="pl-c1">None</span>
        <span class="pl-v">self</span>.last_exception <span class="pl-k">=</span> <span class="pl-c1">None</span>

    <span class="pl-k">def</span> <span class="pl-en">run_code</span>(<span class="pl-smi">self</span>, <span class="pl-smi">code</span>, <span class="pl-smi">global_names</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">local_names</span><span class="pl-k">=</span><span class="pl-c1">None</span>):
        <span class="pl-s"><span class="pl-pds">"""</span> An entry point to execute code using the virtual machine.<span class="pl-pds">"""</span></span>
        frame <span class="pl-k">=</span> <span class="pl-v">self</span>.make_frame(code, <span class="pl-smi">global_names</span><span class="pl-k">=</span>global_names, 
                                <span class="pl-smi">local_names</span><span class="pl-k">=</span>local_names)
        <span class="pl-v">self</span>.run_frame(frame)
</pre></div>

<h3>
<a id="the-frame-class" class="anchor" href="#the-frame-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>The <code>Frame</code> Class</h3>

<p>Next we'll write the <code>Frame</code> object. The frame is a collection of attributes with no methods. As mentioned above, the attributes include the code object created by the compiler; the local, global, and builtin namespaces; a reference to the previous frame; a data stack; a block stack; and the last instruction executed. (We have to do a little extra work to get to the builtin namespace because Python treats this namespace differently in different modules; this detail is not important to the virtual machine.)</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">Frame</span>(<span class="pl-e"><span class="pl-c1">object</span></span>):
    <span class="pl-k">def</span> <span class="pl-en"><span class="pl-c1">__init__</span></span>(<span class="pl-smi">self</span>, <span class="pl-smi">code_obj</span>, <span class="pl-smi">global_names</span>, <span class="pl-smi">local_names</span>, <span class="pl-smi">prev_frame</span>):
        <span class="pl-v">self</span>.code_obj <span class="pl-k">=</span> code_obj
        <span class="pl-v">self</span>.global_names <span class="pl-k">=</span> global_names
        <span class="pl-v">self</span>.local_names <span class="pl-k">=</span> local_names
        <span class="pl-v">self</span>.prev_frame <span class="pl-k">=</span> prev_frame
        <span class="pl-v">self</span>.stack <span class="pl-k">=</span> []
        <span class="pl-k">if</span> prev_frame:
            <span class="pl-v">self</span>.builtin_names <span class="pl-k">=</span> prev_frame.builtin_names
        <span class="pl-k">else</span>:
            <span class="pl-v">self</span>.builtin_names <span class="pl-k">=</span> local_names[<span class="pl-s"><span class="pl-pds">'</span>__builtins__<span class="pl-pds">'</span></span>]
            <span class="pl-k">if</span> <span class="pl-c1">hasattr</span>(<span class="pl-v">self</span>.builtin_names, <span class="pl-s"><span class="pl-pds">'</span>__dict__<span class="pl-pds">'</span></span>):
                <span class="pl-v">self</span>.builtin_names <span class="pl-k">=</span> <span class="pl-v">self</span>.builtin_names.<span class="pl-c1">__dict__</span>

        <span class="pl-v">self</span>.last_instruction <span class="pl-k">=</span> <span class="pl-c1">0</span>
        <span class="pl-v">self</span>.block_stack <span class="pl-k">=</span> []</pre></div>

<p>Next, we'll add frame manipulation to the virtual machine. There are three helper functions for frames: one to create new frames (which is responsible for sorting out the namespaces for the new frame) and one each to push and pop frames on and off the frame stack. A fourth function, <code>run_frame</code>, does the main work of executing a frame. We'll come back to this soon.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">VirtualMachine</span>(<span class="pl-e"><span class="pl-c1">object</span></span>):
    [... snip ...]

    <span class="pl-c"># Frame manipulation</span>
    <span class="pl-k">def</span> <span class="pl-en">make_frame</span>(<span class="pl-smi">self</span>, <span class="pl-smi">code</span>, <span class="pl-smi">callargs</span><span class="pl-k">=</span>{}, <span class="pl-smi">global_names</span><span class="pl-k">=</span><span class="pl-c1">None</span>, <span class="pl-smi">local_names</span><span class="pl-k">=</span><span class="pl-c1">None</span>):
        <span class="pl-k">if</span> global_names <span class="pl-k">is</span> <span class="pl-k">not</span> <span class="pl-c1">None</span> <span class="pl-k">and</span> local_names <span class="pl-k">is</span> <span class="pl-k">not</span> <span class="pl-c1">None</span>:
            local_names <span class="pl-k">=</span> global_names
        <span class="pl-k">elif</span> <span class="pl-v">self</span>.frames:
            global_names <span class="pl-k">=</span> <span class="pl-v">self</span>.frame.global_names
            local_names <span class="pl-k">=</span> {}
        <span class="pl-k">else</span>:
            global_names <span class="pl-k">=</span> local_names <span class="pl-k">=</span> {
                <span class="pl-s"><span class="pl-pds">'</span>__builtins__<span class="pl-pds">'</span></span>: __builtins__,
                <span class="pl-s"><span class="pl-pds">'</span>__name__<span class="pl-pds">'</span></span>: <span class="pl-s"><span class="pl-pds">'</span>__main__<span class="pl-pds">'</span></span>,
                <span class="pl-s"><span class="pl-pds">'</span>__doc__<span class="pl-pds">'</span></span>: <span class="pl-c1">None</span>,
                <span class="pl-s"><span class="pl-pds">'</span>__package__<span class="pl-pds">'</span></span>: <span class="pl-c1">None</span>,
            }
        local_names.update(callargs)
        frame <span class="pl-k">=</span> Frame(code, global_names, local_names, <span class="pl-v">self</span>.frame)
        <span class="pl-k">return</span> frame

    <span class="pl-k">def</span> <span class="pl-en">push_frame</span>(<span class="pl-smi">self</span>, <span class="pl-smi">frame</span>):
        <span class="pl-v">self</span>.frames.append(frame)
        <span class="pl-v">self</span>.frame <span class="pl-k">=</span> frame

    <span class="pl-k">def</span> <span class="pl-en">pop_frame</span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.frames.pop()
        <span class="pl-k">if</span> <span class="pl-v">self</span>.frames:
            <span class="pl-v">self</span>.frame <span class="pl-k">=</span> <span class="pl-v">self</span>.frames[<span class="pl-k">-</span><span class="pl-c1">1</span>]
        <span class="pl-k">else</span>:
            <span class="pl-v">self</span>.frame <span class="pl-k">=</span> <span class="pl-c1">None</span>

    <span class="pl-k">def</span> <span class="pl-en">run_frame</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">pass</span>
        <span class="pl-c"># we'll come back to this shortly</span></pre></div>

<h3>
<a id="the-function-class" class="anchor" href="#the-function-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>The <code>Function</code> Class</h3>

<p>The implementation of the <code>Function</code> object is somewhat twisty, and most of the details aren't critical to understanding the interpreter. The important thing to notice is that calling a function --- invoking the <code>__call__</code> method --- creates a new <code>Frame</code> object and starts running it.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">Function</span>(<span class="pl-e"><span class="pl-c1">object</span></span>):
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    Create a realistic function object, defining the things the interpreter expects.</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    <span class="pl-c1">__slots__</span> <span class="pl-k">=</span> [
        <span class="pl-s"><span class="pl-pds">'</span>func_code<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>func_name<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>func_defaults<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>func_globals<span class="pl-pds">'</span></span>,
        <span class="pl-s"><span class="pl-pds">'</span>func_locals<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>func_dict<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>func_closure<span class="pl-pds">'</span></span>,
        <span class="pl-s"><span class="pl-pds">'</span>__name__<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>__dict__<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>__doc__<span class="pl-pds">'</span></span>,
        <span class="pl-s"><span class="pl-pds">'</span>_vm<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>_func<span class="pl-pds">'</span></span>,
    ]

    <span class="pl-k">def</span> <span class="pl-en"><span class="pl-c1">__init__</span></span>(<span class="pl-smi">self</span>, <span class="pl-smi">name</span>, <span class="pl-smi">code</span>, <span class="pl-smi">globs</span>, <span class="pl-smi">defaults</span>, <span class="pl-smi">closure</span>, <span class="pl-smi">vm</span>):
        <span class="pl-s"><span class="pl-pds">"""</span>You don't need to follow this closely to understand the interpreter.<span class="pl-pds">"""</span></span>
        <span class="pl-v">self</span>._vm <span class="pl-k">=</span> vm
        <span class="pl-v">self</span>.func_code <span class="pl-k">=</span> code
        <span class="pl-v">self</span>.func_name <span class="pl-k">=</span> <span class="pl-v">self</span>.<span class="pl-c1">__name__</span> <span class="pl-k">=</span> name <span class="pl-k">or</span> code.co_name
        <span class="pl-v">self</span>.func_defaults <span class="pl-k">=</span> <span class="pl-c1">tuple</span>(defaults)
        <span class="pl-v">self</span>.func_globals <span class="pl-k">=</span> globs
        <span class="pl-v">self</span>.func_locals <span class="pl-k">=</span> <span class="pl-v">self</span>._vm.frame.f_locals
        <span class="pl-v">self</span>.<span class="pl-c1">__dict__</span> <span class="pl-k">=</span> {}
        <span class="pl-v">self</span>.func_closure <span class="pl-k">=</span> closure
        <span class="pl-v">self</span>.<span class="pl-c1">__doc__</span> <span class="pl-k">=</span> code.co_consts[<span class="pl-c1">0</span>] <span class="pl-k">if</span> code.co_consts <span class="pl-k">else</span> <span class="pl-c1">None</span>

        <span class="pl-c"># Sometimes, we need a real Python function.  This is for that.</span>
        kw <span class="pl-k">=</span> {
            <span class="pl-s"><span class="pl-pds">'</span>argdefs<span class="pl-pds">'</span></span>: <span class="pl-v">self</span>.func_defaults,
        }
        <span class="pl-k">if</span> closure:
            kw[<span class="pl-s"><span class="pl-pds">'</span>closure<span class="pl-pds">'</span></span>] <span class="pl-k">=</span> <span class="pl-c1">tuple</span>(make_cell(<span class="pl-c1">0</span>) <span class="pl-k">for</span> _ <span class="pl-k">in</span> closure)
        <span class="pl-v">self</span>._func <span class="pl-k">=</span> types.FunctionType(code, globs, <span class="pl-k">**</span>kw)

    <span class="pl-k">def</span> <span class="pl-en"><span class="pl-c1">__call__</span></span>(<span class="pl-smi">self</span>, *<span class="pl-smi">args</span>, **<span class="pl-smi">kwargs</span>):
        <span class="pl-s"><span class="pl-pds">"""</span>When calling a Function, make a new frame and run it.<span class="pl-pds">"""</span></span>
        callargs <span class="pl-k">=</span> inspect.getcallargs(<span class="pl-v">self</span>._func, <span class="pl-k">*</span>args, <span class="pl-k">**</span>kwargs)
        <span class="pl-c"># Use callargs to provide a mapping of arguments: values to pass into the new </span>
        <span class="pl-c"># frame.</span>
        frame <span class="pl-k">=</span> <span class="pl-v">self</span>._vm.make_frame(
            <span class="pl-v">self</span>.func_code, callargs, <span class="pl-v">self</span>.func_globals, {}
        )
        <span class="pl-k">return</span> <span class="pl-v">self</span>._vm.run_frame(frame)

<span class="pl-k">def</span> <span class="pl-en">make_cell</span>(<span class="pl-smi">value</span>):
    <span class="pl-s"><span class="pl-pds">"""</span>Create a real Python closure and grab a cell.<span class="pl-pds">"""</span></span>
    <span class="pl-c"># Thanks to Alex Gaynor for help with this bit of twistiness.</span>
    fn <span class="pl-k">=</span> (<span class="pl-k">lambda</span> <span class="pl-smi">x</span>: <span class="pl-k">lambda</span>: x)(value)
    <span class="pl-k">return</span> fn.<span class="pl-c1">__closure__</span>[<span class="pl-c1">0</span>]</pre></div>

<p>Next, back on the <code>VirtualMachine</code> object, we'll add some helper methods for data stack manipulation. The bytecodes that manipulate the stack always operate on the current frame's data stack. This will make our implementations of <code>POP_TOP</code>, <code>LOAD_FAST</code>, and all the other instructions that touch the stack more readable.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">VirtualMachine</span>(<span class="pl-e"><span class="pl-c1">object</span></span>):
    [... snip ...]

    <span class="pl-c"># Data stack manipulation</span>
    <span class="pl-k">def</span> <span class="pl-en">top</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> <span class="pl-v">self</span>.frame.stack[<span class="pl-k">-</span><span class="pl-c1">1</span>]

    <span class="pl-k">def</span> <span class="pl-en">pop</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> <span class="pl-v">self</span>.frame.stack.pop()

    <span class="pl-k">def</span> <span class="pl-en">push</span>(<span class="pl-smi">self</span>, *<span class="pl-smi">vals</span>):
        <span class="pl-v">self</span>.frame.stack.extend(vals)

    <span class="pl-k">def</span> <span class="pl-en">popn</span>(<span class="pl-smi">self</span>, <span class="pl-smi">n</span>):
        <span class="pl-s"><span class="pl-pds">"""</span>Pop a number of values from the value stack.</span>
<span class="pl-s">        A list of `n` values is returned, the deepest value first.</span>
<span class="pl-s">        <span class="pl-pds">"""</span></span>
        <span class="pl-k">if</span> n:
            ret <span class="pl-k">=</span> <span class="pl-v">self</span>.frame.stack[<span class="pl-k">-</span>n:]
            <span class="pl-v">self</span>.frame.stack[<span class="pl-k">-</span>n:] <span class="pl-k">=</span> []
            <span class="pl-k">return</span> ret
        <span class="pl-k">else</span>:
            <span class="pl-k">return</span> []</pre></div>

<p>Before we get to running a frame, we need two more methods. </p>

<p>The first, <code>parse_byte_and_args</code>, takes a bytecode, checks if it has arguments, and parses the arguments if so. This method also updates the frame's attribute <code>last_instruction</code>, a reference to the last instruction executed. A single instruction is one byte long if it doesn't have an argument, and three bytes if it does have an argument; the last two bytes are the argument.  The meaning of the argument to each instruction depends on which instruction it is. For example, as mentioned above, for <code>POP_JUMP_IF_FALSE</code>, the argument to the instruction is the jump target.  For <code>BUILD_LIST</code>, the argument is the number of elements in the list. For <code>LOAD_CONST</code>, it's an index into the list of constants.</p>

<p>Some instructions use simple numbers as their arguments. For others, the virtual machine has to do a little work to discover what the arguments mean.  The <code>dis</code> module in the standard library exposes a cheatsheet explaining what arguments have what meaning, which makes our code more compact.  For example, the list <code>dis.hasname</code> tells us that the arguments to <code>LOAD_NAME</code>, <code>IMPORT_NAME</code>, <code>LOAD_GLOBAL</code>, and nine other instructions have the same meaning: for these instructions, the argument represents an index into the list of names on the code object.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">VirtualMachine</span>(<span class="pl-e"><span class="pl-c1">object</span></span>):
    [... snip ...]

    <span class="pl-k">def</span> <span class="pl-en">parse_byte_and_args</span>(<span class="pl-smi">self</span>):
        f <span class="pl-k">=</span> <span class="pl-v">self</span>.frame
        opoffset <span class="pl-k">=</span> f.last_instruction
        byteCode <span class="pl-k">=</span> f.code_obj.co_code[opoffset]
        f.last_instruction <span class="pl-k">+=</span> <span class="pl-c1">1</span>
        byte_name <span class="pl-k">=</span> dis.opname[byteCode]
        <span class="pl-k">if</span> byteCode <span class="pl-k">&gt;=</span> dis.HAVE_ARGUMENT:
            <span class="pl-c"># index into the bytecode</span>
            arg <span class="pl-k">=</span> f.code_obj.co_code[f.last_instruction:f.last_instruction<span class="pl-k">+</span><span class="pl-c1">2</span>]  
            f.last_instruction <span class="pl-k">+=</span> <span class="pl-c1">2</span>   <span class="pl-c"># advance the instruction pointer</span>
            arg_val <span class="pl-k">=</span> arg[<span class="pl-c1">0</span>] <span class="pl-k">+</span> (arg[<span class="pl-c1">1</span>] <span class="pl-k">*</span> <span class="pl-c1">256</span>)
            <span class="pl-k">if</span> byteCode <span class="pl-k">in</span> dis.hasconst:   <span class="pl-c"># Look up a constant</span>
                arg <span class="pl-k">=</span> f.code_obj.co_consts[arg_val]
            <span class="pl-k">elif</span> byteCode <span class="pl-k">in</span> dis.hasname:  <span class="pl-c"># Look up a name</span>
                arg <span class="pl-k">=</span> f.code_obj.co_names[arg_val]
            <span class="pl-k">elif</span> byteCode <span class="pl-k">in</span> dis.haslocal: <span class="pl-c"># Look up a local name</span>
                arg <span class="pl-k">=</span> f.code_obj.co_varnames[arg_val]
            <span class="pl-k">elif</span> byteCode <span class="pl-k">in</span> dis.hasjrel:  <span class="pl-c"># Calculate a relative jump</span>
                arg <span class="pl-k">=</span> f.last_instruction <span class="pl-k">+</span> arg_val
            <span class="pl-k">else</span>:
                arg <span class="pl-k">=</span> arg_val
            argument <span class="pl-k">=</span> [arg]
        <span class="pl-k">else</span>:
            argument <span class="pl-k">=</span> []

        <span class="pl-k">return</span> byte_name, argument</pre></div>

<p>The next method is <code>dispatch</code>, which looks up the operations for a given instruction and executes them. In the CPython interpreter, this dispatch is done with a giant switch statement that spans 1,500 lines!  Luckily, since we're writing Python, we can be more compact.  We'll define a method for each byte name and then use <code>getattr</code> to look it up. Like in the toy interpreter above, if our instruction is named <code>FOO_BAR</code>, the corresponding method would be named <code>byte_FOO_BAR</code>. For the moment, we'll leave the content of these methods as a black box.  Each bytecode method will return either <code>None</code> or a string, called <code>why</code>, which is an extra piece of state the interpreter needs in some cases.  These return values of the individual instruction methods are used only as internal indicators of interpreter state --- don't confuse these with return values from executing frames.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">VirtualMachine</span>(<span class="pl-e"><span class="pl-c1">object</span></span>):
    [... snip ...]

    <span class="pl-k">def</span> <span class="pl-en">dispatch</span>(<span class="pl-smi">self</span>, <span class="pl-smi">byte_name</span>, <span class="pl-smi">argument</span>):
        <span class="pl-s"><span class="pl-pds">"""</span> Dispatch by bytename to the corresponding methods.</span>
<span class="pl-s">        Exceptions are caught and set on the virtual machine.<span class="pl-pds">"""</span></span>

        <span class="pl-c"># When later unwinding the block stack,</span>
        <span class="pl-c"># we need to keep track of why we are doing it.</span>
        why <span class="pl-k">=</span> <span class="pl-c1">None</span>
        <span class="pl-k">try</span>:
            bytecode_fn <span class="pl-k">=</span> <span class="pl-c1">getattr</span>(<span class="pl-v">self</span>, <span class="pl-s"><span class="pl-pds">'</span>byte_<span class="pl-c1">%s</span><span class="pl-pds">'</span></span> <span class="pl-k">%</span> byte_name, <span class="pl-c1">None</span>)
            <span class="pl-k">if</span> bytecode_fn <span class="pl-k">is</span> <span class="pl-c1">None</span>:
                <span class="pl-k">if</span> byte_name.startswith(<span class="pl-s"><span class="pl-pds">'</span>UNARY_<span class="pl-pds">'</span></span>):
                    <span class="pl-v">self</span>.unaryOperator(byte_name[<span class="pl-c1">6</span>:])
                <span class="pl-k">elif</span> byte_name.startswith(<span class="pl-s"><span class="pl-pds">'</span>BINARY_<span class="pl-pds">'</span></span>):
                    <span class="pl-v">self</span>.binaryOperator(byte_name[<span class="pl-c1">7</span>:])
                <span class="pl-k">else</span>:
                    <span class="pl-k">raise</span> VirtualMachineError(
                        <span class="pl-s"><span class="pl-pds">"</span>unsupported bytecode type: <span class="pl-c1">%s</span><span class="pl-pds">"</span></span> <span class="pl-k">%</span> byte_name
                    )
            <span class="pl-k">else</span>:
                why <span class="pl-k">=</span> bytecode_fn(<span class="pl-k">*</span>argument)
        <span class="pl-k">except</span>:
            <span class="pl-c"># deal with exceptions encountered while executing the op.</span>
            <span class="pl-v">self</span>.last_exception <span class="pl-k">=</span> sys.exc_info()[:<span class="pl-c1">2</span>] <span class="pl-k">+</span> (<span class="pl-c1">None</span>,)
            why <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>exception<span class="pl-pds">'</span></span>

        <span class="pl-k">return</span> why

    <span class="pl-k">def</span> <span class="pl-en">run_frame</span>(<span class="pl-smi">self</span>, <span class="pl-smi">frame</span>):
        <span class="pl-s"><span class="pl-pds">"""</span>Run a frame until it returns (somehow).</span>
<span class="pl-s">        Exceptions are raised, the return value is returned.</span>
<span class="pl-s">        <span class="pl-pds">"""</span></span>
        <span class="pl-v">self</span>.push_frame(frame)
        <span class="pl-k">while</span> <span class="pl-c1">True</span>:
            byte_name, arguments <span class="pl-k">=</span> <span class="pl-v">self</span>.parse_byte_and_args()

            why <span class="pl-k">=</span> <span class="pl-v">self</span>.dispatch(byte_name, arguments)

            <span class="pl-c"># Deal with any block management we need to do</span>
            <span class="pl-k">while</span> why <span class="pl-k">and</span> frame.block_stack:
                why <span class="pl-k">=</span> <span class="pl-v">self</span>.manage_block_stack(why)

            <span class="pl-k">if</span> why:
                <span class="pl-k">break</span>

        <span class="pl-v">self</span>.pop_frame()

        <span class="pl-k">if</span> why <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>exception<span class="pl-pds">'</span></span>:
            exc, val, tb <span class="pl-k">=</span> <span class="pl-v">self</span>.last_exception
            e <span class="pl-k">=</span> exc(val)
            e.__traceback__ <span class="pl-k">=</span> tb
            <span class="pl-k">raise</span> e

        <span class="pl-k">return</span> <span class="pl-v">self</span>.return_value</pre></div>

<h3>
<a id="the-block-class" class="anchor" href="#the-block-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>The <code>Block</code> Class</h3>

<p>Before we implement the methods for each bytecode instruction, we'll briefly discuss blocks. A block is used for certain kinds of flow control, specifically exception handling and looping. The block is reponsible for making sure that the data stack is in the appropriate state when the operation is finished.  For example, in a loop, a special iterator object remains on the stack while the loop is running, but is popped off when it is finished. The interpreter must keep track of whether the loop is continuing or is finished.</p>

<p>To keep track of this extra piece of information, the interpreter sets a flag to indicate its state.  We implement this flag as a variable called <code>why</code>, which can be <code>None</code> or one of the strings <code>"continue"</code>, <code>"break"</code>, <code>"exception"</code>, or <code>"return"</code>. This indicates what kind of manipulation of the block stack and data stack should happen.  To return to the iterator example, if the top of the block stack is a <code>loop</code> block and the <code>why</code> code is <code>continue</code>, the iterator object should remain on the data stack, but if the <code>why</code> code is <code>break</code>, it should be popped off.</p>

<p>The precise details of block manipulation are rather fiddly, and we won't spend more time on this, but interested readers are encouraged to take a careful look.</p>

<div class="highlight highlight-source-python"><pre>Block <span class="pl-k">=</span> collections.namedtuple(<span class="pl-s"><span class="pl-pds">"</span>Block<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>type, handler, stack_height<span class="pl-pds">"</span></span>)

<span class="pl-k">class</span> <span class="pl-en">VirtualMachine</span>(<span class="pl-e"><span class="pl-c1">object</span></span>):
    [... snip ...]

    <span class="pl-c"># Block stack manipulation</span>
    <span class="pl-k">def</span> <span class="pl-en">push_block</span>(<span class="pl-smi">self</span>, <span class="pl-smi">b_type</span>, <span class="pl-smi">handler</span><span class="pl-k">=</span><span class="pl-c1">None</span>):
        level <span class="pl-k">=</span> <span class="pl-c1">len</span>(<span class="pl-v">self</span>.frame.stack)
        <span class="pl-v">self</span>.frame.block_stack.append(Block(b_type, handler, stack_height))

    <span class="pl-k">def</span> <span class="pl-en">pop_block</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> <span class="pl-v">self</span>.frame.block_stack.pop()

    <span class="pl-k">def</span> <span class="pl-en">unwind_block</span>(<span class="pl-smi">self</span>, <span class="pl-smi">block</span>):
        <span class="pl-s"><span class="pl-pds">"""</span>Unwind the values on the data stack corresponding to a given block.<span class="pl-pds">"""</span></span>
        <span class="pl-k">if</span> block.type <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>except-handler<span class="pl-pds">'</span></span>:
            <span class="pl-c"># The exception itself is on the stack as type, value, and traceback.</span>
            offset <span class="pl-k">=</span> <span class="pl-c1">3</span>  
        <span class="pl-k">else</span>:
            offset <span class="pl-k">=</span> <span class="pl-c1">0</span>

        <span class="pl-k">while</span> <span class="pl-c1">len</span>(<span class="pl-v">self</span>.frame.stack) <span class="pl-k">&gt;</span> block.level <span class="pl-k">+</span> offset:
            <span class="pl-v">self</span>.pop()

        <span class="pl-k">if</span> block.type <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>except-handler<span class="pl-pds">'</span></span>:
            traceback, value, exctype <span class="pl-k">=</span> <span class="pl-v">self</span>.popn(<span class="pl-c1">3</span>)
            <span class="pl-v">self</span>.last_exception <span class="pl-k">=</span> exctype, value, traceback

    <span class="pl-k">def</span> <span class="pl-en">manage_block_stack</span>(<span class="pl-smi">self</span>, <span class="pl-smi">why</span>):
        <span class="pl-s"><span class="pl-pds">"""</span> <span class="pl-pds">"""</span></span>
        frame <span class="pl-k">=</span> <span class="pl-v">self</span>.frame
        block <span class="pl-k">=</span> frame.block_stack[<span class="pl-k">-</span><span class="pl-c1">1</span>]
        <span class="pl-k">if</span> block.type <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>loop<span class="pl-pds">'</span></span> <span class="pl-k">and</span> why <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>continue<span class="pl-pds">'</span></span>:
            <span class="pl-v">self</span>.jump(<span class="pl-v">self</span>.return_value)
            why <span class="pl-k">=</span> <span class="pl-c1">None</span>
            <span class="pl-k">return</span> why

        <span class="pl-v">self</span>.pop_block()
        <span class="pl-v">self</span>.unwind_block(block)

        <span class="pl-k">if</span> block.type <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>loop<span class="pl-pds">'</span></span> <span class="pl-k">and</span> why <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>break<span class="pl-pds">'</span></span>:
            why <span class="pl-k">=</span> <span class="pl-c1">None</span>
            <span class="pl-v">self</span>.jump(block.handler)
            <span class="pl-k">return</span> why

        <span class="pl-k">if</span> (block.type <span class="pl-k">in</span> [<span class="pl-s"><span class="pl-pds">'</span>setup-except<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>finally<span class="pl-pds">'</span></span>] <span class="pl-k">and</span> why <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>exception<span class="pl-pds">'</span></span>):
            <span class="pl-v">self</span>.push_block(<span class="pl-s"><span class="pl-pds">'</span>except-handler<span class="pl-pds">'</span></span>)
            exctype, value, tb <span class="pl-k">=</span> <span class="pl-v">self</span>.last_exception
            <span class="pl-v">self</span>.push(tb, value, exctype)
            <span class="pl-v">self</span>.push(tb, value, exctype) <span class="pl-c"># yes, twice</span>
            why <span class="pl-k">=</span> <span class="pl-c1">None</span>
            <span class="pl-v">self</span>.jump(block.handler)
            <span class="pl-k">return</span> why

        <span class="pl-k">elif</span> block.type <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">'</span>finally<span class="pl-pds">'</span></span>:
            <span class="pl-k">if</span> why <span class="pl-k">in</span> (<span class="pl-s"><span class="pl-pds">'</span>return<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>continue<span class="pl-pds">'</span></span>):
                <span class="pl-v">self</span>.push(<span class="pl-v">self</span>.return_value)

            <span class="pl-v">self</span>.push(why)

            why <span class="pl-k">=</span> <span class="pl-c1">None</span>
            <span class="pl-v">self</span>.jump(block.handler)
            <span class="pl-k">return</span> why
        <span class="pl-k">return</span> why</pre></div>

<h2>
<a id="the-instructions" class="anchor" href="#the-instructions" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Instructions</h2>

<p>All that's left is to implement the dozens of methods for instructions: <code>byte_LOAD_FAST</code>, <code>byte_BINARY_MODULO</code>, and so on. The actual instructions are the least interesting part of the interpreter, so we show only a handful here, but the full implementation is available at <a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a>. (Enough instructions are included here to execute all the code samples that we disassembled above.)</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">class</span> <span class="pl-en">VirtualMachine</span>(<span class="pl-e"><span class="pl-c1">object</span></span>):
    [... snip ...]

    <span class="pl-c">## Stack manipulation</span>

    <span class="pl-k">def</span> <span class="pl-en">byte_LOAD_CONST</span>(<span class="pl-smi">self</span>, <span class="pl-smi">const</span>):
        <span class="pl-v">self</span>.push(const)

    <span class="pl-k">def</span> <span class="pl-en">byte_POP_TOP</span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.pop()

    <span class="pl-c">## Names</span>
    <span class="pl-k">def</span> <span class="pl-en">byte_LOAD_NAME</span>(<span class="pl-smi">self</span>, <span class="pl-smi">name</span>):
        frame <span class="pl-k">=</span> <span class="pl-v">self</span>.frame
        <span class="pl-k">if</span> name <span class="pl-k">in</span> frame.f_locals:
            val <span class="pl-k">=</span> frame.f_locals[name]
        <span class="pl-k">elif</span> name <span class="pl-k">in</span> frame.f_globals:
            val <span class="pl-k">=</span> frame.f_globals[name]
        <span class="pl-k">elif</span> name <span class="pl-k">in</span> frame.f_builtins:
            val <span class="pl-k">=</span> frame.f_builtins[name]
        <span class="pl-k">else</span>:
            <span class="pl-k">raise</span> <span class="pl-c1">NameError</span>(<span class="pl-s"><span class="pl-pds">"</span>name '<span class="pl-c1">%s</span>' is not defined<span class="pl-pds">"</span></span> <span class="pl-k">%</span> name)
        <span class="pl-v">self</span>.push(val)

    <span class="pl-k">def</span> <span class="pl-en">byte_STORE_NAME</span>(<span class="pl-smi">self</span>, <span class="pl-smi">name</span>):
        <span class="pl-v">self</span>.frame.f_locals[name] <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()

    <span class="pl-k">def</span> <span class="pl-en">byte_LOAD_FAST</span>(<span class="pl-smi">self</span>, <span class="pl-smi">name</span>):
        <span class="pl-k">if</span> name <span class="pl-k">in</span> <span class="pl-v">self</span>.frame.f_locals:
            val <span class="pl-k">=</span> <span class="pl-v">self</span>.frame.f_locals[name]
        <span class="pl-k">else</span>:
            <span class="pl-k">raise</span> <span class="pl-c1">UnboundLocalError</span>(
                <span class="pl-s"><span class="pl-pds">"</span>local variable '<span class="pl-c1">%s</span>' referenced before assignment<span class="pl-pds">"</span></span> <span class="pl-k">%</span> name
            )
        <span class="pl-v">self</span>.push(val)

    <span class="pl-k">def</span> <span class="pl-en">byte_STORE_FAST</span>(<span class="pl-smi">self</span>, <span class="pl-smi">name</span>):
        <span class="pl-v">self</span>.frame.f_locals[name] <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()

    <span class="pl-k">def</span> <span class="pl-en">byte_LOAD_GLOBAL</span>(<span class="pl-smi">self</span>, <span class="pl-smi">name</span>):
        f <span class="pl-k">=</span> <span class="pl-v">self</span>.frame
        <span class="pl-k">if</span> name <span class="pl-k">in</span> f.f_globals:
            val <span class="pl-k">=</span> f.f_globals[name]
        <span class="pl-k">elif</span> name <span class="pl-k">in</span> f.f_builtins:
            val <span class="pl-k">=</span> f.f_builtins[name]
        <span class="pl-k">else</span>:
            <span class="pl-k">raise</span> <span class="pl-c1">NameError</span>(<span class="pl-s"><span class="pl-pds">"</span>global name '<span class="pl-c1">%s</span>' is not defined<span class="pl-pds">"</span></span> <span class="pl-k">%</span> name)
        <span class="pl-v">self</span>.push(val)

    <span class="pl-c">## Operators</span>

    BINARY_OPERATORS <span class="pl-k">=</span> {
        <span class="pl-s"><span class="pl-pds">'</span>POWER<span class="pl-pds">'</span></span>:    <span class="pl-c1">pow</span>,
        <span class="pl-s"><span class="pl-pds">'</span>MULTIPLY<span class="pl-pds">'</span></span>: operator.mul,
        <span class="pl-s"><span class="pl-pds">'</span>FLOOR_DIVIDE<span class="pl-pds">'</span></span>: operator.floordiv,
        <span class="pl-s"><span class="pl-pds">'</span>TRUE_DIVIDE<span class="pl-pds">'</span></span>:  operator.truediv,
        <span class="pl-s"><span class="pl-pds">'</span>MODULO<span class="pl-pds">'</span></span>:   operator.mod,
        <span class="pl-s"><span class="pl-pds">'</span>ADD<span class="pl-pds">'</span></span>:      operator.add,
        <span class="pl-s"><span class="pl-pds">'</span>SUBTRACT<span class="pl-pds">'</span></span>: operator.sub,
        <span class="pl-s"><span class="pl-pds">'</span>SUBSCR<span class="pl-pds">'</span></span>:   operator.getitem,
        <span class="pl-s"><span class="pl-pds">'</span>LSHIFT<span class="pl-pds">'</span></span>:   operator.lshift,
        <span class="pl-s"><span class="pl-pds">'</span>RSHIFT<span class="pl-pds">'</span></span>:   operator.rshift,
        <span class="pl-s"><span class="pl-pds">'</span>AND<span class="pl-pds">'</span></span>:      operator.and_,
        <span class="pl-s"><span class="pl-pds">'</span>XOR<span class="pl-pds">'</span></span>:      operator.xor,
        <span class="pl-s"><span class="pl-pds">'</span>OR<span class="pl-pds">'</span></span>:       operator.or_,
    }

    <span class="pl-k">def</span> <span class="pl-en">binaryOperator</span>(<span class="pl-smi">self</span>, <span class="pl-smi">op</span>):
        x, y <span class="pl-k">=</span> <span class="pl-v">self</span>.popn(<span class="pl-c1">2</span>)
        <span class="pl-v">self</span>.push(<span class="pl-v">self</span>.BINARY_OPERATORS[op](x, y))

    COMPARE_OPERATORS <span class="pl-k">=</span> [
        operator.lt,
        operator.le,
        operator.eq,
        operator.ne,
        operator.gt,
        operator.ge,
        <span class="pl-k">lambda</span> <span class="pl-smi">x</span>, <span class="pl-smi">y</span>: x <span class="pl-k">in</span> y,
        <span class="pl-k">lambda</span> <span class="pl-smi">x</span>, <span class="pl-smi">y</span>: x <span class="pl-k">not</span> <span class="pl-k">in</span> y,
        <span class="pl-k">lambda</span> <span class="pl-smi">x</span>, <span class="pl-smi">y</span>: x <span class="pl-k">is</span> y,
        <span class="pl-k">lambda</span> <span class="pl-smi">x</span>, <span class="pl-smi">y</span>: x <span class="pl-k">is</span> <span class="pl-k">not</span> y,
        <span class="pl-k">lambda</span> <span class="pl-smi">x</span>, <span class="pl-smi">y</span>: <span class="pl-c1">issubclass</span>(x, <span class="pl-c1">Exception</span>) <span class="pl-k">and</span> <span class="pl-c1">issubclass</span>(x, y),
    ]

    <span class="pl-k">def</span> <span class="pl-en">byte_COMPARE_OP</span>(<span class="pl-smi">self</span>, <span class="pl-smi">opnum</span>):
        x, y <span class="pl-k">=</span> <span class="pl-v">self</span>.popn(<span class="pl-c1">2</span>)
        <span class="pl-v">self</span>.push(<span class="pl-v">self</span>.COMPARE_OPERATORS[opnum](x, y))

    <span class="pl-c">## Attributes and indexing</span>

    <span class="pl-k">def</span> <span class="pl-en">byte_LOAD_ATTR</span>(<span class="pl-smi">self</span>, <span class="pl-smi">attr</span>):
        obj <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()
        val <span class="pl-k">=</span> <span class="pl-c1">getattr</span>(obj, attr)
        <span class="pl-v">self</span>.push(val)

    <span class="pl-k">def</span> <span class="pl-en">byte_STORE_ATTR</span>(<span class="pl-smi">self</span>, <span class="pl-smi">name</span>):
        val, obj <span class="pl-k">=</span> <span class="pl-v">self</span>.popn(<span class="pl-c1">2</span>)
        <span class="pl-c1">setattr</span>(obj, name, val)

    <span class="pl-c">## Building</span>

    <span class="pl-k">def</span> <span class="pl-en">byte_BUILD_LIST</span>(<span class="pl-smi">self</span>, <span class="pl-smi">count</span>):
        elts <span class="pl-k">=</span> <span class="pl-v">self</span>.popn(count)
        <span class="pl-v">self</span>.push(elts)

    <span class="pl-k">def</span> <span class="pl-en">byte_BUILD_MAP</span>(<span class="pl-smi">self</span>, <span class="pl-smi">size</span>):
        <span class="pl-v">self</span>.push({})

    <span class="pl-k">def</span> <span class="pl-en">byte_STORE_MAP</span>(<span class="pl-smi">self</span>):
        the_map, val, key <span class="pl-k">=</span> <span class="pl-v">self</span>.popn(<span class="pl-c1">3</span>)
        the_map[key] <span class="pl-k">=</span> val
        <span class="pl-v">self</span>.push(the_map)

    <span class="pl-k">def</span> <span class="pl-en">byte_LIST_APPEND</span>(<span class="pl-smi">self</span>, <span class="pl-smi">count</span>):
        val <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()
        the_list <span class="pl-k">=</span> <span class="pl-v">self</span>.frame.stack[<span class="pl-k">-</span>count] <span class="pl-c"># peek</span>
        the_list.append(val)

    <span class="pl-c">## Jumps</span>

    <span class="pl-k">def</span> <span class="pl-en">byte_JUMP_FORWARD</span>(<span class="pl-smi">self</span>, <span class="pl-smi">jump</span>):
        <span class="pl-v">self</span>.jump(jump)

    <span class="pl-k">def</span> <span class="pl-en">byte_JUMP_ABSOLUTE</span>(<span class="pl-smi">self</span>, <span class="pl-smi">jump</span>):
        <span class="pl-v">self</span>.jump(jump)

    <span class="pl-k">def</span> <span class="pl-en">byte_POP_JUMP_IF_TRUE</span>(<span class="pl-smi">self</span>, <span class="pl-smi">jump</span>):
        val <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()
        <span class="pl-k">if</span> val:
            <span class="pl-v">self</span>.jump(jump)

    <span class="pl-k">def</span> <span class="pl-en">byte_POP_JUMP_IF_FALSE</span>(<span class="pl-smi">self</span>, <span class="pl-smi">jump</span>):
        val <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()
        <span class="pl-k">if</span> <span class="pl-k">not</span> val:
            <span class="pl-v">self</span>.jump(jump)

    <span class="pl-c">## Blocks</span>

    <span class="pl-k">def</span> <span class="pl-en">byte_SETUP_LOOP</span>(<span class="pl-smi">self</span>, <span class="pl-smi">dest</span>):
        <span class="pl-v">self</span>.push_block(<span class="pl-s"><span class="pl-pds">'</span>loop<span class="pl-pds">'</span></span>, dest)

    <span class="pl-k">def</span> <span class="pl-en">byte_GET_ITER</span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.push(<span class="pl-c1">iter</span>(<span class="pl-v">self</span>.pop()))

    <span class="pl-k">def</span> <span class="pl-en">byte_FOR_ITER</span>(<span class="pl-smi">self</span>, <span class="pl-smi">jump</span>):
        iterobj <span class="pl-k">=</span> <span class="pl-v">self</span>.top()
        <span class="pl-k">try</span>:
            v <span class="pl-k">=</span> <span class="pl-c1">next</span>(iterobj)
            <span class="pl-v">self</span>.push(v)
        <span class="pl-k">except</span> <span class="pl-c1">StopIteration</span>:
            <span class="pl-v">self</span>.pop()
            <span class="pl-v">self</span>.jump(jump)

    <span class="pl-k">def</span> <span class="pl-en">byte_BREAK_LOOP</span>(<span class="pl-smi">self</span>):
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>break<span class="pl-pds">'</span></span>

    <span class="pl-k">def</span> <span class="pl-en">byte_POP_BLOCK</span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.pop_block()

    <span class="pl-c">## Functions</span>

    <span class="pl-k">def</span> <span class="pl-en">byte_MAKE_FUNCTION</span>(<span class="pl-smi">self</span>, <span class="pl-smi">argc</span>):
        name <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()
        code <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()
        defaults <span class="pl-k">=</span> <span class="pl-v">self</span>.popn(argc)
        globs <span class="pl-k">=</span> <span class="pl-v">self</span>.frame.f_globals
        fn <span class="pl-k">=</span> Function(name, code, globs, defaults, <span class="pl-c1">None</span>, <span class="pl-v">self</span>)
        <span class="pl-v">self</span>.push(fn)

    <span class="pl-k">def</span> <span class="pl-en">byte_CALL_FUNCTION</span>(<span class="pl-smi">self</span>, <span class="pl-smi">arg</span>):
        lenKw, lenPos <span class="pl-k">=</span> <span class="pl-c1">divmod</span>(arg, <span class="pl-c1">256</span>) <span class="pl-c"># KWargs not supported here</span>
        posargs <span class="pl-k">=</span> <span class="pl-v">self</span>.popn(lenPos)

        func <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()
        frame <span class="pl-k">=</span> <span class="pl-v">self</span>.frame
        retval <span class="pl-k">=</span> func(<span class="pl-k">*</span>posargs)
        <span class="pl-v">self</span>.push(retval)

    <span class="pl-k">def</span> <span class="pl-en">byte_RETURN_VALUE</span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.return_value <span class="pl-k">=</span> <span class="pl-v">self</span>.pop()
        <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">"</span>return<span class="pl-pds">"</span></span></pre></div>

<h2>
<a id="dynamic-typing-what-the-compiler-doesnt-know" class="anchor" href="#dynamic-typing-what-the-compiler-doesnt-know" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dynamic Typing: What the Compiler Doesn't Know</h2>

<p>One thing you've probably heard is that Python is a "dynamic" language --- particularly that it's "dynamically typed". The context we've just built up on the interpreter sheds some light on this description.</p>

<p>One of the things "dynamic" means in this context is that a lot of work is done at run time. We saw earlier that the Python compiler doesn't have much information about what the code actually does. For example, consider the short function <code>mod</code> below. <code>mod</code> takes two arguments and returns the first modulo the second. In the bytecode, we see that the variables <code>a</code> and <code>b</code> are loaded, then the bytecode <code>BINARY_MODULO</code> performs the modulo operation itself.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-k">def</span> mod(a, b):
...    <span class="pl-k">return</span> a <span class="pl-k">%</span> b
<span class="pl-k">&gt;&gt;&gt;</span> dis.dis(mod)
  <span class="pl-c1">2</span>           <span class="pl-c1">0</span> LOAD_FAST                <span class="pl-c1">0</span> (a)
              <span class="pl-c1">3</span> LOAD_FAST                <span class="pl-c1">1</span> (b)
              <span class="pl-c1">6</span> BINARY_MODULO
              <span class="pl-c1">7</span> RETURN_VALUE
<span class="pl-k">&gt;&gt;&gt;</span> mod(<span class="pl-c1">19</span>, <span class="pl-c1">5</span>)
<span class="pl-c1">4</span></pre></div>

<p>Calculating 19 <code>%</code> 5 yields 4 --- no surprise there. What happens if we call it with different kinds of arguments?</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">&gt;&gt;&gt;</span> mod(<span class="pl-s"><span class="pl-pds">"</span>by<span class="pl-c1">%s</span>de<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>teco<span class="pl-pds">"</span></span>)
<span class="pl-s"><span class="pl-pds">'</span>bytecode<span class="pl-pds">'</span></span></pre></div>

<p>What just happened? You've probably seen this syntax before, but in a different context: string formatting.</p>

<pre><code>&gt;&gt;&gt; print("by%sde" % "teco")
bytecode
</code></pre>

<p>Using the symbol <code>%</code> to format a string for printing means invoking the instruction <code>BINARY_MODULO</code>. This instruction mods together the top two values on the stack when the instruction executes --- regardless of whether they're strings, integers, or instances of a class you defined yourself. The bytecode was generated when the function was compiled (effectively, when it was defined) and the same bytecode is used with different types of arguments.</p>

<p>The Python compiler knows relatively little about the effect the bytecode will have. It's up to the interpreter to determine the type of the object that <code>BINARY_MODULO</code> is operating on and do the right thing for that type. This is why Python is described as <em>dynamically typed</em>: you don't know the types of the arguments to this function until you actually run it. By contrast, in a language that's statically typed, the programmer tells the compiler up front what type the arguments will be (or the compiler figures them out for itself).</p>

<p>The compiler's ignorance is one of the challenges to optimizing Python or analyzing it statically --- just looking at the bytecode, without actually running the code, you don't know what each instruction will do! In fact, you could define a class that implements the <code>__mod__</code> method, and Python would invoke that method if you use <code>%</code> on your objects. So <code>BINARY_MODULO</code> could actually run any code at all!</p>

<p>Just looking at the following code, the first calculation of <code>a % b</code> seems wasteful.</p>

<div class="highlight highlight-source-python"><pre><span class="pl-k">def</span> <span class="pl-en">mod</span>(<span class="pl-smi">a</span>,<span class="pl-smi">b</span>):
    a <span class="pl-k">%</span> b
    <span class="pl-k">return</span> a <span class="pl-k">%</span>b</pre></div>

<p>Unfortunately, a static analysis of this code --- the kind of you can do without running it --- can't be certain that the first <code>a % b</code> really does nothing. Calling <code>__mod__</code> with <code>%</code> might write to a file, or interact with another part of your program, or do literally anything else that's possible in Python. It's hard to optimize a function when you don't know what it does! In Russell Power and Alex Rubinsteyn's great paper "How fast can we make interpreted Python?", they note, "In the general absence of type information, each instruction must be treated as <code>INVOKE_ARBITRARY_METHOD</code>."</p>

<h2>
<a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h2>

<p>Byterun is a compact Python interpreter that's easier to understand than CPython. Byterun replicates CPython's primary structural details: a stack-based interpreter operating on instruction sets called bytecode. It steps or jumps through these instructions, pushing to and popping from a stack of data. The interpreter creates, destroys, and jumps between frames as it calls into and returns from functions and generators. Byterun shares the real interpreter's limitations, too: because Python uses dynamic typing, the interpreter must work hard at run time to determine the correct behavior for any series of instructions.</p>

<p>I encourage you to disassemble your own programs and to run them using Byterun. You'll quickly run into instructions that this shorter version of Byterun doesn't implement. The full implementation can be found at <a href="https://github.com/nedbat/byterun">https://github.com/nedbat/byterun</a> --- or, by carefully reading the real CPython interpreter's <code>ceval.c</code>, you can implement it yourself!</p>

<h2>
<a id="acknowledgements" class="anchor" href="#acknowledgements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Acknowledgements</h2>

<p>Thanks to Ned Batchelder for originating this project and guiding my contributions, Michael Arntzenius for his help debugging the code and editing the prose, Leta Montopoli for her edits, and the entire Recurse Center community for their support and interest. Any errors are my own.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/qingyunha/taotao">Taotao</a> is maintained by <a href="https://github.com/qingyunha">qingyunha</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
